% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\graphicspath{ {./img/} }

\input{solidity-highlighting.tex}	% copy the file from this repo
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{Ants-Review: A Protocol For Open Anonymous Peer-Reviews\thanks{Supported by ETHTurin}}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Bianca Trovò\inst{1,2}\orcidID{0000-0002-6776-2304} \and
Nazzareno Massari\inst{2,3}\orcidID{0000-0002-6638-2174}}
%
\authorrunning{B. Trovò et N. Massari}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Sorbonne Université, Faculté des Sciences et Ingénierie, 75005 Paris, France \and
Neurospin research center, CEA/SAC/DSV/I2BM, 91191 Gif-sur-Yvette, France
\email{bianca.trovo@alumni.unitn.it}\\
\and
Polytechnic of Turin\\
\email{nazzareno@nazzarenomassari.com}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Peer-review is a necessary and essential quality control step for scientific publications. However, the process, which is very costly in terms of time investment, not only is not remunerated but it’s also not recognized by the academic community as a relevant scientific output for a researcher. Therefore, scientific dissemination is affected. Here, to solve this issue we propose a blockchain-based incentive protocol that rewards scientists also for their contributions to other scientists’ work and that builds up a reputational system. We designed a basic Bounty-like contract called AntsReview that allows any author to issue a call for peer-reviewing their scientific publication. If requirements are met, peer-reviews will be audited by an external editor and payed by the Issuer. To promote ethical behaviour the system will implement a quadratic funding on AntsReview.
\keywords{Blockchain  \and Peer-review \and Privacy \and Incentivization.}
\end{abstract}
%
%
\section{Introduction}

\section{Background}
\subsection{Peer-review}
Peer-review is the traditional and necessary process at the heart of quality control in science [9, 12], determining the destinies of articles’ publications and therefore of scientific dissemination. However, the current peer-review system is outdated: in the past, it was effective when scholarly communication happened exclusively through printed paper journals, but nowadays, with the high and fast-paced levels of articles productions, its slow and multistage process doesn’t keep up with the times. Indeed, articles submitted to journals can take from months to years after editors’ first scrutiny, going back and forth several review rounds before acceptance for publications. This is mainly due to the fact that the reviewers that are normally appointed by authors and/or editors are actually full-time researchers themselves, who work on a volunteer basis taking time from their primary research. Though things are changing, and now more and more journals encourage a transparent peer review process with the publication of reviewers names and reports, in most of the cases, to guarantee an unbiased output, journals don’t even get credit researchers for this form of unpaid work. On top of this, author-level metrics that measure the scientific impact and productivity of academics, such as the h-index, and are taken into account by the funding agencies, are purely based on the number of citations per each publications while neglecting the full spectrum of scientific contributions (software, data collection, presentations, reviews…). Therefore, peer-reviewing is an intellectual investment without any external return for researchers’ career. A major consequence of not promoting incentives for the quality (and quantity) of peer-reviews is to either have good research unpublished (because unreviewed) and abandoned in preprint archives or bad science published through sloppy and uncritical reviews [5]. Last but not least, the ‘publish or perish’ culture has been more and more inducing malicious behaviour during the peer-review process, such as attempts of scientific fraud (authors trying to review their own papers) and abuse (reviewers producing extremely harsh reviews to damage competitors by blocking the publication of their ideas). Finally, the current peer-review system is usually not double-blind, thus making its decisional process vulnerable to all forms of biases (gender bias, cultural bias, professional bias, etc...). These trust problems are one of the major issues facing scholarly communication.
\subsection{Blockchain for science}
An increasing body of voices in the scientific community has started to speak up for the need of updating current scientific practices with the advances represented by blockchain technology [2, 8]. As an example, we refer to a ‘manifesto’ written by a few anonymous authors, proposing a blockchain based system of academic endorsement (AES) [1]. Indeed, we could say that in general “specific blockchain characteristics meet the requirements of an open science infrastructure” [3-7]: decentralisation, taking out the need of intermediaries, would make useless depending on highly profiting publishing companies for disseminating scientific work and managing the rules of the peer-review process; immutability of the system in which information can only be appended with tamper proof-time stamping,  but not subsequently modified, would secure the intellectual property and a fairer measure of the scientific contribution of the actors at play during the multiple versions of a paper; transparency (meaning that we have a viewable record of all the transactions), would also make editorial decisions (publish or not publish a study) more transparent and democratic. Finally, cryptographic hashing could allow for a double-blind process that reduces human biases in judgement by assigning hashed pseudonymous to universal researcher identifiers. From all these aspects taken together, a more democratic open peer-review  process could rise, in which merit and power (of access to information, of decision…) is more equally redistributed among the stakeholders (researchers, reviewers, taxpayers).

\section{System concept}
For the above mentioned reasons, we propose an incentive-based protocol called Ants-Review to reward open peer-reviews while preserving the anonymity of the reviewers. The name originates from the idea that the work behind a finished scientific paper resembles a complex organism such as an anthill, which emerges from the sum of many individualities: in it, all contributions (even if ‘micro’) are essential to the whole and are worth recognition.
This project is intended to be open source and was developed during the ETH Turin 2020 Hackathon and it’s design and attempt of implementation are exposed in the following section.

\subsection{Design}
When authors of a paper submit their draft to an open access journal or preprint, they can instantiate a call (bounty issuance) for the paper-review whose fulfillment rules are set in a smart-contract to which any contributor can participate either as a reviewer or as editor. Reviews fulfilling the smart-contract requirements are audited by external editors who validate the content. If the reviews are accepted (bounty fulfillment), reviewers awarded a token, an internal digital currency specific for this bounty, called ‘ANT’. The ideal scenario envisages multiple contributions both from the reviewers actors and the editors actors. To reinforce ethical behaviour and the system will implement on AntsReview a quadratic funding [20].

\subsection{Implementation}
AntsReview is a destributed peer-review system which synthetizes successfull ideas from previous systems including The Bounty Network[ref], ERC20[ref], AZTEC Protocol[ref], IPFS[ref], Proof of Existence[ref], ...
\newline The contribution of AntsReview is simply allowing the peer-review process, as a complex system, to emerge as a self-organised ecosystem of authors and peer-reviewers to enhance the complexity of a paper and its validation.
\newline AntsReview represent a new platform to issue peer-reviews and validate scientific papers and a new system for anonymous and open contributions with an incentivization mechanism to reach an ideal state of equilibrium and create value.
\newline The AntsReview Protocol is divided into stack of sub-protocols responsible for different functionality:

\includegraphics[scale=0.28]{AntsReview}

\begin{enumerate}
  \item \textbf{Bounty} - manage access management and the basic system.
  \item \textbf{Token Economics} - manage system incentivization mechanism integrating ideas from DeFi and Quadratic Funding.
  \item \textbf{Privacy} - mantains the anonymity of the system via AZTEC Protocol.
\end{enumerate}

\subsubsection{Bounty}
AntsReview is the core of the smart contracts deployed on Ethereum Rinkeby's Testnet as shown in the flow-chart[img].
\newline It implements a Bounty-like system where an issuer (author) is asked a serious of actions, to ensure transparency and robustness, regarding the AntReview that he's creating:
\begin{itemize}
  \item to upload the file containing the requirements of the peer-review and the paper into IPFS.
  \item to speficy a deadline in the form of a unix timestamp after wich the fulfillment will no longer be accepted.
  \item to send the amount of ether for the reward.
\end{itemize}

AntsReviewRoles, to ensure integrity of the system, implements an access management, leveraging on AccessControl.sol by OpenZeppelin Library, through the creation of the Roles Issuer and Peer-Reviewer[code].
\newline It also integrates a circuit breaker deisgn pattern via Pausable.sol by OpenZeppelin to allow the Pauser Role, that by default is the Owner of the Smart Contracts, to pause (or unpause) the functions in case of emergency.

\begin{lstlisting}[language=Solidity]

pragma solidity 0.6.8;

import "@openzeppelin/contracts/access/AccessControl.sol";

contract AntsReviewRoles is AccessControl {

/// Roles
bytes32 public constant ISSUER_ROLE = keccak256("ISSUER_ROLE");
bytes32 public constant PEER_REVIEWER_ROLE = keccak256("PEER_REVIEWER_ROLE");

}
\end{lstlisting}

In this way, only the Issuer (author) can create a new AntReview.
\newline Once created, an AntReview is available to be fulfilled by Peer-Reviewers, uploading the peer-review on IPFS before the deadline.
\newline The AntReview after being validated is then accepted by the Issuer and paid equally between Peer-Reviewers.
\newline Also, the Issuer can cancel the AntReview at any time and withdraw the amount of ether staked.
\newline One of the key aspects of the protocol is the concept of Proof of Existence, introduced by Stuart Haber & W. Scott Stornetta with the paper "How to time-stamp a digital document"[cit.].
\newline As the pioneer of blockchain an cited by Bitcoin whitepaper, they were in a mission to solve the problem of immutability of digital records that became reality with the Blockchain and Bitcoin as its first application.
\newline In Ethereum the concept of immutablity is achieved via the blockchain and proof of work consesus algorithm by a chain of timestamped block hashes that are secured by miners competing computations.
\newline AntsReview is evaluating the advantages of storing the hashes of the peer-reviews into a Merkle Tree to achieve immutability.

\subsubsection{Token Economics}
AntsReview, to incintivize the system integrates a native ERC20 Token called Ant that is used in the protocol to pay for AntReview and also wrapped into zkAnt to allow anonymous payments.

The code below show the implementation of Ant Token via ERC20PresetMinterPauser.sol inherited from OpenZeppelin Library, a preset of ERc20 inlcuding an access management and a circuit breaker pattern.

\begin{lstlisting}[language=Solidity]

pragma solidity 0.6.8;

import "@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol";

contract Ant is ERC20PresetMinterPauser {

  constructor()
  ERC20PresetMinterPauser("Ant", "ANT")
  public {

  }
}
\end{lstlisting}

\newline


\subsubsection{Privacy}



\subsubsection{Future steps}
Future integrations that were not contemplated in the above presented PoC /demo but that we plan to cover for the development of the AntsReview bounty include: an ERC20 token, named Ant,  symbol ANT; Proof of Existence (PoE) service; memory storage on IPFS; moreover, since we wanted to anonymize peer-reviews to protect the contributors privacy, we would like to implement on the ANT token a fast, non-interactive type of zero-knowledge privacy protocol to enable private transactions on Ethereum. Zero-knowledge proof is a mathematical cryptographic method that through values permutations allows one party (the prover) to prove to another (the verifier) the veracity of a statement, without having to reveal what the statement is. We will use ZK-SNARKs (which stands for “Zero-Knowledge Succinct Non-Interactive Argument of Knowledge”) via the open source libraries of AZTEC protocol [15]. We will also use Ethereum Name Service (ENS) [14] to allow for human-readable Ethereum addresses; Upgradability Design Patterns [13] via Proxy, to allow the logic to be extended and improved; De-Fi integrations such as Dai, Chai. Finally, we would like to propose for AntsReview Quadratic Funding, a design written by Vitalik Buterin and co [20] and which applies concepts inspired by quadratic voting to funding public goods.

\section{Conclusion and Discussions}
In this whitepaper we addressed a central problem within the quality control academic dissemination: the peer-review process. We showed how blockchain technology could provide an efficient and viable solution and open up possibile directions for a change in paradigm in scientific communication. We proposed an incentive mechanism that could solve the problems of lack of acknowledgment and trust during peer-review. We exposed the architecture of our project and our Proof of Concept (PoC) for which we adopted cutting-edge tools from the open source blockchain community.

\section{Supplementary material}
Our open source code is available at the Github repository. A demo of the project is available at Youtube channel.
\section{CRediT Authorship Contribution Statement}
Bianca Trovò: Conceptualization, Investigation, Visualization, Writing - original draft, Writing - review \& editing. Nazzareno Massari: Project administration, Methodology, Validation, Software development. Both authors equally contributed and supervised the project.
\section{Declaration of Competing Interest}
The authors declare no competing interests.

\newpage

\section{Appendix}

\appendix

\section{AntsReviewRoles.sol}

\begin{lstlisting}[language=Solidity]

  /// SPDX-License-Identifier: GPL-3.0
  pragma solidity 0.6.8;

  ///@title AntsReview
  ///@author Nazzareno Massari
  ///@notice AntsReviewRoles Access Management for Issuer and Peer-Reviewer
  ///@dev All function calls are currently implemented without side effecs through TDD approach
  ///@dev OpenZeppelin library is used for secure contract development

  import "@openzeppelin/contracts/access/Ownable.sol";
  import "@openzeppelin/contracts/access/AccessControl.sol";
  import "@openzeppelin/contracts/utils/Pausable.sol";

  contract AntsReviewRoles is Ownable, AccessControl, Pausable {

    /// Roles
    bytes32 public constant ISSUER_ROLE = keccak256("ISSUER_ROLE");
    bytes32 public constant PEER_REVIEWER_ROLE = keccak256("PEER_REVIEWER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");


    constructor() public {
            _setupRole(DEFAULT_ADMIN_ROLE, owner());
            _setupRole(PAUSER_ROLE, owner());
    }

      /// Modifiers
      modifier onlyAdmin() {
          require(isAdmin(msg.sender), "Caller is not an admin");
          _;
        }

      modifier onlyIssuer() {
          require(isIssuer(msg.sender), "Caller is not an issuer");
          _;
      }

      modifier onlyPeerReviewer() {
          require(isPeerReviewer(msg.sender), "Caller is not a peer-reviewer");
          _;
      }

      /// Functions

      function isAdmin(address account) public view returns (bool) {
        return hasRole(DEFAULT_ADMIN_ROLE, account);
      }

      function isIssuer(address account ) public view returns (bool) {
        return hasRole(ISSUER_ROLE, account);
      }

      function isPeerReviewer(address account ) public view returns (bool) {
        return hasRole(PEER_REVIEWER_ROLE, account);
      }

      function addIssuer(address account) public onlyAdmin returns (bool) {
        require(!isIssuer(account), "Account is already an issuer");
        grantRole(ISSUER_ROLE, account);
        return true;
      }

      function addPeerReviewer(address account) public onlyAdmin returns (bool) {
        require(!isPeerReviewer(account), "Account is already a peer-reviewer");
        grantRole(PEER_REVIEWER_ROLE, account);
        return true;
      }

      function removeIssuer(address account) public onlyAdmin returns (bool) {
        require(isIssuer(account), "Account is not an issuer");
        revokeRole(ISSUER_ROLE, account);
        return true;
      }

      function removePeerReviewer(address account) public onlyAdmin returns (bool) {
        require(isPeerReviewer(account), "Account is not a peer-reviewer");
        revokeRole(PEER_REVIEWER_ROLE, account);
        return true;
      }

      /// @notice Pause all the functions
      /// @dev the caller must have the 'PAUSER_ROLE'
      function pause() public {
        require(hasRole(PAUSER_ROLE, msg.sender), "BadgeFactory: must have pauser role to pause");
        _pause();
      }

      /// @notice Unpause all the functions
      /// @dev the caller must have the 'PAUSER_ROLE'
      function unpause() public {
            require(hasRole(PAUSER_ROLE, msg.sender), "BadgeFactory: must have pauser role to unpause");
            _unpause();
      }
  }

\end{lstlisting}

\newpage
\section{AntsReview.sol}

\begin{lstlisting}[language=Solidity]
  /// SPDX-License-Identifier: GPL-3.0
  pragma solidity 0.6.8;

  ///@title AntsReview
  ///@author Nazzareno Massari
  ///@notice AntsReview to allows issuer to issue an antReview which peer-reviewers can fulfill
  ///@dev All function calls are currently implemented without side effecs through TDD approach
  ///@dev OpenZeppelin library is used for secure contract development

  import "./AntsReviewRoles.sol";
  import "@openzeppelin/contracts/math/SafeMath.sol";
  import "@openzeppelin/contracts/utils/Address.sol";
  import "@openzeppelin/contracts/utils/Counters.sol";

  interface AntToken {
    function transfer(address reciptient, uint amount) external returns (bool);
    function balanceOf(address account) external view returns (uint);
  }

  contract AntsReview is AntsReviewRoles {

    using SafeMath for uint256;
    using Address for address payable;
    using Counters for Counters.Counter;

    /// Enums
    enum AntReviewStatus { CREATED, ACCEPTED, CANCELLED }

    /// Token
    AntToken internal ant;

    /// Counter
    Counters.Counter private _antReviewIdTracker;

    /// Storage
    AntReview[] public antreviews;

    mapping(uint256 => Peer_Review[]) peer_reviews;

    /// Structs
    struct AntReview {
        address payable issuer;
        uint256 deadline;
        string ipfs_hash;
        AntReviewStatus status;
        uint256 amount; //in wei
    }

    struct Peer_Review {
        bool accepted;
        address payable peer_reviewer;
        string ipfs_hash;
    }


    /// Events

    event AntReviewIssued(address issuer, uint256 amount, string ipfsHash);
    event AntReviewFulfilled(uint256 antReviewId, address peer_reviewer, uint256 peerReviewId, string ipfsHash);
    event AntReviewAccepted(uint256 antReviewId, address issuer, address peer_reviewer, uint256 indexed peerReviewId, uint256 amount);
    event AntReviewCancelled(uint256 indexed antReviewId, address indexed issuer, uint256 amount);

    constructor(address ant_) public {
      ant = AntToken(ant_);
    }

    /// Fallback

    fallback() external payable {
      revert();
    }

    receive() external payable {
      revert();
    }

    /// Modifiers

    modifier hasValue() {
        require(msg.value > 0);
        _;
    }

    modifier antReviewExists(uint256 _antReviewId){
      require(_antReviewId < antreviews.length);
      _;
    }

    modifier peerReviewExists(uint256 _antReviewId, uint256 _peerReviewId){
      require(_peerReviewId < peer_reviews[_antReviewId].length);
      _;
    }

    modifier hasStatus(uint256 _antReviewId, AntReviewStatus _desiredStatus) {
      require(antreviews[_antReviewId].status == _desiredStatus);
      _;
    }

    modifier peerReviewNotYetAccepted(uint256 _antReviewId, uint256 _peerReviewId) {
      require(peer_reviews[_antReviewId][_peerReviewId].accepted == false);
      _;
    }

    modifier validateDeadline(uint256 _newDeadline) {
        require(_newDeadline > now);
        _;
    }

    modifier isBeforeDeadline(uint256 _antReviewId) {
      require(now < antreviews[_antReviewId].deadline);
      _;
    }


    ///@notice Instantiates a new AntReview
    ///@dev Access restricted to Issuer
    ///@param _deadline The unix timestamp after which fulfillments will no longer be accepted
    ///@param _ipfsHash The IPFS Hash of the Scientific Paper
    ///@return True If the antReview is successfully issued
    function issueAntReview(
        string calldata _ipfsHash,
        uint64 _deadline
    )
        external
        payable
        hasValue()
        validateDeadline(_deadline)
        onlyIssuer()
        whenNotPaused()
        returns (bool)
    {
        _antReviewIdTracker.increment();
        antreviews.push(AntReview(msg.sender, _deadline, _ipfsHash, AntReviewStatus.CREATED, msg.value));
        emit AntReviewIssued(msg.sender, msg.value, _ipfsHash);
        return true;
    }


    ///@notice Submit a fulfillment for the given antReview
    ///@dev Access restricted to Peer-Reviewer
    ///@param _antReviewId The index of the antReview to be fufilled
    ///@param _ipfsHash The IPFS Hash which contains evidence of the fufillment
    ///@return True If the AntReview is successfully fulfilled
    function fulfillAntReview(uint256 _antReviewId, string memory _ipfsHash)
      public
      antReviewExists(_antReviewId)
      onlyPeerReviewer()
      hasStatus(_antReviewId, AntReviewStatus.CREATED)
      isBeforeDeadline(_antReviewId)
      whenNotPaused()
      returns (bool)
    {
      peer_reviews[_antReviewId].push(Peer_Review(false, msg.sender, _ipfsHash));
      emit AntReviewFulfilled(_antReviewId, msg.sender, (peer_reviews[_antReviewId].length.sub(1)),_ipfsHash);
      return true;
    }


    ///@notice Accept a given Peer-Review
    ///@dev Access restricted to Issuer
    ///@param _antReviewId the index of the antReview
    ///@param _peerReviewId the index of the fulfillment being accepted
    ///@return True If the AntReview is successfully being accepted
    function acceptAntReview(uint256 _antReviewId, uint256 _peerReviewId)
        public
        antReviewExists(_antReviewId)
        peerReviewExists(_antReviewId,_peerReviewId)
        onlyIssuer()
        hasStatus(_antReviewId, AntReviewStatus.CREATED)
        peerReviewNotYetAccepted(_antReviewId, _peerReviewId)
        whenNotPaused()
        returns (bool)
    {
        peer_reviews[_antReviewId][_peerReviewId].accepted = true;
        antreviews[_antReviewId].status = AntReviewStatus.ACCEPTED;
        peer_reviews[_antReviewId][_peerReviewId].peer_reviewer.sendValue(antreviews[_antReviewId].amount);
        emit AntReviewAccepted(
          _antReviewId,
          antreviews[_antReviewId].issuer,
          peer_reviews[_antReviewId][_peerReviewId].peer_reviewer,
          _peerReviewId, antreviews[_antReviewId].amount
        );
        return true;
    }


    ///@notice Cancels the antReview and send the funds back to the issuer
    ///@dev Access restricted to Issuer
    ///@param _antReviewId the index of the antReview
    ///@return True If the AntReview is successfully cancelled
    function cancelAntReview(uint256 _antReviewId)
        public
        antReviewExists(_antReviewId)
        onlyIssuer()
        hasStatus(_antReviewId, AntReviewStatus.CREATED)
        whenNotPaused()
        returns (bool)
    {
        antreviews[_antReviewId].status = AntReviewStatus.CANCELLED;
        antreviews[_antReviewId].issuer.sendValue(antreviews[_antReviewId].amount);
        emit AntReviewCancelled(_antReviewId, msg.sender, antreviews[_antReviewId].amount);
        return true;
    }

  }

\end{lstlisting}

\newpage
\section{Ant.sol}

\begin{lstlisting}[language=Solidity]
  /// SPDX-License-Identifier: GPL-3.0
  pragma solidity 0.6.8;

  ///@title AntsReview
  ///@author Nazzareno Massari
  ///@notice Ant ERC20 Token
  ///@dev All function calls are currently implemented without side effecs through TDD approach
  ///@dev OpenZeppelin library is used for secure contract development

  import "@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol";


  contract Ant is ERC20PresetMinterPauser {

    constructor()
    ERC20PresetMinterPauser("Ant", "ANT")
    public {

    }

  }
\end{lstlisting}


% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{references.bib}

\end{document}
